<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./style.css" />
    <title>Python</title>
    <style>

      @media only screen and (max-width: 400px) {
    #main-doc {
    margin-left: -10px;
  }

    code {
    margin-left: -20px;
    width: 100%;
    padding: 15px;
    padding-left: 10px;
    padding-right: 45px;
    min-width: 233px;
    }
}
    </style>
</head>
<body>
    <nav id="navbar">
        <header>Python Documentation</header>
    
        <ul>
          <li><a class="nav-link" href="#Introduction">Introduction</a></li> 
          <li><a class="nav-link" href="#Python_Strings">Python Strings</a></li>
          <li><a class="nav-link" href="#Python_Lists">Python Lists</a></li>
          <li><a class="nav-link" href="#Python_Sorting">Python Sorting</a></li>
          <li><a class="nav-link" href="#Dicts_and_files">Dicts and Files</a></li>
          <li><a class="nav-link" href="#Regular_Expressions">Regular Expressions</a></li>
          <li><a class="nav-link" href="#Python_Utilities">Python Utilities</a></li>
          <li><a class="nav-link" href="#Reference">Reference</a></li>
        </ul>
      </nav>
      <main id="main-doc">
        <section class="main-section" id="Introduction">
          <header>Introduction</header>
          <article>
            <h2>What is Python?</h2>
            <p>
                Python is a dynamic, interpreted (bytecode-compiled) language. There are no type declarations 
                of variables, parameters, functions, or methods in source code. This makes the code short and 
                flexible, and you lose the compile-time type checking of the source code. Python tracks the 
                types of all values at runtime and flags code that does not make sense as it runs.
            </p>
            <h2>Python Source Code</h2>
            <p>
                Python source files use the ".py" extension and are called "modules." With a Python module
                <b>hello.py</b>, the easiest way to run it is with the shell command "python hello.py Alice" which 
                calls the Python interpreter to execute the code in hello.py, passing it the command line 
                argument "Alice"
            </p>
            <p>
                Here's a very simple <b>hello.py</b> program
            </p>

              <code>
                  #!/usr/bin/env python

                  # import modules used here -- sys is a very standard one
                  import sys
                  
                  # Gather our code in a main() function
                  def main():
                      print 'Hello there', sys.argv[1]
                      # Command line args are in sys.argv[1], sys.argv[2] ...
                      # sys.argv[0] is the script name itself and can be ignored
                  
                  # Standard boilerplate to call the main() function to begin
                  # the program.
                  if __name__ == '__main__':
                      main()
              </code>

              <p>Running this program from the command line looks like:</p>
              <code>
                  $ python hello.py Guido
                  Hello there Guido
                  $ ./hello.py Alice  ## without needing 'python' first (Unix)
                  Hello there Alice
              </code>

          </article>
        </section>
        <section class="main-section" id="Python_Strings">
            <header>Python Strings</header>
            <article>
              <h2>Strings</h2>
              <p>
                  Python has a built-in string class named "str" with many handy features (there is an older 
                  module named "string" which you should not use). String literals can be enclosed by either 
                  double or single quotes, although single quotes are more commonly used. 
                  A double quoted string literal can contain single quotes without any fuss (e.g. "I didn't do it") and likewise single 
                  quoted string can contain double quotes.
                  <ul>
                    <li>
                        Python strings are "immutable" which means they cannot be changed after they are created.
                    </li>
                    <li>
                        Since strings can't be changed, we construct *new* strings as we go to represent computed values
                    </li>
                  </ul>
                  <code>
                      s = 'hi'
                      print s[1]          ## i
                      print len(s)        ## 2
                      print s + ' there'  ## hi there
                  </code>
              </p>
              <h2>String Methods</h2>
              <p>
                  Here are some of the most common string methods. A method is like a function, but it runs "on" an object.
                  If the variable s is a string, then the code s.lower() runs the lower() method on that string object and returns 
                  the result (this idea of a method running on an object is one of the basic ideas that make up Object Oriented Programming, OOP).
                   Here are some of the most common string methods:
              </p>
              <ul>
                <li>
                    s.lower(), s.upper() -- returns the lowercase or uppercase version of the string
                </li>
                <li>
                    s.strip() -- returns a string with whitespace removed from the start and end

                </li>
                <li>
                    s.isalpha()/s.isdigit()/s.isspace()... -- tests if all the string chars are in the various character classes
                </li>
                <li>
                    s.startswith('other'), s.endswith('other') -- tests if the string starts or ends with the given other string

                </li>
                <li>
                    s.find('other') -- searches for the given other string (not a regular expression) within s, and returns the first index where it begins or -1 if not found
                </li>
                <li>
                    s.replace('old', 'new') -- returns a string where all occurrences of 'old' have been replaced by 'new'
                </li>
                <li>
                    s.split('delim') -- returns a list of substrings separated by the given delimiter. The delimiter is not a regular expression, it's just text. 'aaa,bbb,ccc'.split(',') -> ['aaa', 'bbb', 'ccc']. As a convenient special case s.split() (with no arguments) splits on all whitespace chars.

                </li>
                <li>
                    s.join(list) -- opposite of split(), joins the elements in the given list together using the string as the delimiter. e.g. '---'.join(['aaa', 'bbb', 'ccc']) -> aaa---bbb---ccc

                </li>
              </ul>
              
            </article>
          </section>
          <section class="main-section" id="Python_Lists">
              <header>Python Lists</header>
              <article>
                <h2>What is a list?</h2>
                <p>
                    Python has a great built-in list type named "list". List literals are written within square brackets [ ]. 
                    Lists work similarly to strings -- use the len() function and square brackets [ ] to access data, 
                    with the first element at index 0.
                </p>
                <code>
                    colors = ['red', 'blue', 'green']
                    print colors[0]    ## red
                    print colors[2]    ## green
                    print len(colors)  ## 3
                </code>
                <h2>FOR and IN</h2>
                <p>
                    Python's *for* and *in* constructs are extremely useful, and the first use of them we'll see is with lists. 
                    The *for* construct -- for var in list -- is an easy way to look at each element in a list (or other collection). 
                    Do not add or remove from the list during iteration.
                </p>
                <code>
                    squares = [1, 4, 9, 16]
                    sum = 0
                    for num in squares:
                      sum += num
                    print sum  ## 30
                </code>
              <h2>Range</h2>
              <p>
                  The range(n) function yields the numbers 0, 1, ... n-1, and range(a, b) returns a, a+1, ... b-1 -- up to but not including the last number. The combination of the for-loop and the range() function allow you to build a traditional numeric for loop:
              </p>
              <code>
                  ## print the numbers from 0 through 99
                   for i in range(100):
                      print i
              </code>
              </article>
            </section>

            <section class="main-section" id="Python_Sorting">
                <header>Python Sorting</header>
                <article>
                  
                  <p>
                      The easiest way to sort is with the sorted(list) function, which takes a list and returns a new list with those elements in sorted order. 
                      The original list is not changed.
                  </p>
                  <code>
                      a = [5, 1, 4, 3]
                      print sorted(a)  ## [1, 3, 4, 5]
                      print a  ## [5, 1, 4, 3]
                  </code>
                  <h2>Custom Sorting with key</h2>
                  <p>
                      For more complex custom sorting, sorted() takes an optional "key=" specifying a "key" function that transforms each element before comparison.
                      The key function takes in 1 value and returns 1 value, and the returned "proxy" value is used for the comparisons within the sort.
                  </p>
                  <code>
                      ## Say we have a list of strings we want to sort by the last letter of the string.
                      strs = ['xc', 'zb', 'yd' ,'wa']
                    
                      ## Write a little function that takes a string, and returns its last letter.
                      ## This will be the key function (takes in 1 value, returns 1 value).
                      def MyFn(s):
                        return s[-1]
                    
                      ## Now pass key=MyFn to sorted() to sort by the last letter:
                      print sorted(strs, key=MyFn)  ## ['wa', 'zb', 'xc', 'yd']
                  </code>

                  <h2>Tuples</h2>
                  <p>
                      A tuple is a fixed size grouping of elements, such as an (x, y) co-ordinate.
                      Tuples are like lists, except they are immutable and do not change size (tuples are not strictly immutable since one of the contained elements could be mutable).
                       Tuples play a sort of "struct" role in Python -- a convenient way to pass around a little logical, fixed size bundle of values.
                  </p>
                  <code>
                      tuple = (1, 2, 'hi')
                      print len(tuple)  ## 3
                      print tuple[2]    ## hi
                      tuple[2] = 'bye'  ## NO, tuples cannot be changed
                      tuple = (1, 2, 'bye')  ## this works
                    
                  </code>
                
                </article>
              </section>

              <section class="main-section" id="Dicts_and_files">
                  <header>Dicts and Files</header>
                  <article>
                    <h2>Dict Hash Table</h2>
                    <p>
                        Python's efficient key/value hash table structure is called a "dict". 
                        The contents of a dict can be written as a series of key:value pairs within braces { }, e.g. dict = {key1:value1, key2:value2, ... }.
                         The "empty dict" is just an empty pair of curly braces {}.
                    </p>
                    <p>
                        Looking up or setting a value in a dict uses square brackets, e.g. dict['foo'] looks up the value under the key 'foo'.
                         Strings, numbers, and tuples work as keys, and any type can be a value. Other types may or may not work correctly as keys (strings and tuples work cleanly since they are immutable).
                          Looking up a value which is not in the dict throws a KeyError -- use "in" to check if the key is in the dict, or use dict.get(key) which returns the value or None if the key is not present (or get(key, not-found) allows you to specify what value to return in the not-found case).
                    </p>
                    <code>
                        ## Can build up a dict by starting with the the empty dict {}
                        ## and storing key/value pairs into the dict like this:
                        ## dict[key] = value-for-that-key
                        dict = {}
                        dict['a'] = 'alpha'
                        dict['g'] = 'gamma'
                        dict['o'] = 'omega'
                      
                        print dict  ## {'a': 'alpha', 'o': 'omega', 'g': 'gamma'}
                      
                        print dict['a']     ## Simple lookup, returns 'alpha'
                        dict['a'] = 6       ## Put new key/value into dict
                        'a' in dict         ## True
                        ## print dict['z']                  ## Throws KeyError
                        if 'z' in dict: print dict['z']     ## Avoid KeyError
                        print dict.get('z')  ## None (instead of KeyError)
                      
                    </code>
                    <h2>Dict Formatting</h2>
                    <p>
                        The % operator works conveniently to substitute values from a dict into a string by name:

                    </p>

                    <code>hash = {}
                        hash['word'] = 'garfield'
                        hash['count'] = 42
                        s = 'I want %(count)d copies of %(word)s' % hash  # %d for int, %s for string
                        # 'I want 42 copies of garfield'
                      </code>
                      <h2>Files</h2>
                      <p>The open() function opens and returns a file handle that can be used to read or write a file in the usual way. The code f = open('name', 'r') opens the file into the variable f, ready for reading operations, and use f.close() when finished. 
                          Instead of 'r', use 'w' for writing, and 'a' for append.
                          The special mode 'rU' is the "Universal" option for text files where it's smart about converting different line-endings so they always come through as a simple '\n'. 
                          The standard for-loop works for text files, iterating through the lines of the file (this works only for text files, not binary files). 
                          The for-loop technique is a simple and efficient way to look at all the lines in a text file: 
                        </p>
                          <code>
                              # Echo the contents of a file
                              f = open('foo.txt', 'rU')
                              for line in f:   ## iterates over the lines of the file
                              print line,    ## trailing , so print does not add an end-of-line char
                              ## since 'line' already includes the end-of-line.
                              f.close()
                          </code>
                  
                  </article>
                </section>
                <section class="main-section" id="Regular_Expressions">
                  <header>Regular Expressions</header>
                  <article>
                    <h2>What are Regular Expression?</h2>
                    <p>
                        Regular expressions are a powerful language for matching text patterns. This page gives a basic introduction to regular expressions themselves sufficient for our Python exercises and shows how regular expressions work in Python. 
                        The Python "re" module provides regular expression support.
                    </p>
                    <code>
                        match = re.search(pat, str)
                    </code>
                    <h2>Basic Patterns</h2>
                    <p>
                        The power of regular expressions is that they can specify patterns, not just fixed characters. 
                        Here are the most basic patterns which match single chars:
                    </p>
                    <ul>
                      <li>
                          a, X, 9, < -- ordinary characters just match themselves exactly. The meta-characters which do not match themselves because they have special meanings are: . ^ $ * + ? { [ ] \ | ( ) (details below)

                      </li>
                      <li>
                          . (a period) -- matches any single character except newline '\n'
                      </li>
                      <li>
                          \w -- (lowercase w) matches a "word" character: a letter or digit or underbar [a-zA-Z0-9_]. Note that although "word" is the mnemonic for this, it only matches a single word char, not a whole word. 
                          \W (upper case W) matches any non-word character.
                      </li>
                      <li>
                          \b -- boundary between word and non-word
                      </li>
                      <li>
                          \s -- (lowercase s) matches a single whitespace character -- space, newline, return, tab, form [ \n\r\t\f]. \S (upper case S) matches any non-whitespace character.
                      </li>
                      <li>
                          \t, \n, \r -- tab, newline, return
                      </li>
                      <li>
                          \d -- decimal digit [0-9] (some older regex utilities do not support but \d, but they all support \w and \s)
                      </li>
                      <li>
                          ^ = start, $ = end -- match the start or end of the string

                      </li>
                      <li>
                          \ -- inhibit the "specialness" of a character. So, for example, use \. to match a period or \\ to match a slash. 
                          If you are unsure if a character has special meaning, such as '@', you can put a slash in front of it, \@, to make sure it is treated just as a character.
                      </li>
                    </ul>
                  
                  </article>
                </section>
                <section class="main-section" id="Python_Utilities">
                    <header>Python Utilities</header>
                    <article>
                      <h2>File System -- os, os.path, shuti</h2>
                      <p>
                          The *os* and *os.path* modules include many functions to interact with the file system. The *shutil* module can copy files.
                      </p>
                      <ul>
                        <li>filenames = os.listdir(dir) -- list of filenames in that directory path (not including . and ..). 
                          The filenames are just the names in the directory, not their absolute paths.
                        </li>
                        <li>
                            os.path.join(dir, filename) -- given a filename from the above list, use this to put the dir and filename together to make a path

                        </li>
                        <li>
                            os.path.abspath(path) -- given a path, return an absolute form, e.g. /home/nick/foo/bar.html

                        </li>
                        <li>
                            os.path.dirname(path), os.path.basename(path) -- given dir/foo/bar.html, return the dirname "dir/foo" and basename "bar.html"
                        </li>
                        <li>
                            os.path.exists(path) -- true if it exists

                        </li>
                        <li>
                            os.mkdir(dir_path) -- makes one dir, os.makedirs(dir_path) makes all the needed dirs in this path

                        </li>
                        <li>
                            shutil.copy(source-path, dest-path) -- copy a file (dest path directories should exist)

                        </li>
                      </ul>
                      <h2>Extension</h2>
                      <p>
                          An exception represents a run-time error that halts the normal execution at a particular line and transfers control to error handling code. 
                          This section just introduces the most basic uses of exceptions. 
                          For example a run-time error might be that a variable used in the program does not have a value (ValueError .. you've probably seen that one a few times), or a file open operation error because a file does not exist (IOError).
                          Learn more in the exceptions tutorial and see the entire exception list.


                      </p>
                      <p>
                          Without any error handling code (as we have done thus far), a run-time exception just halts the program with an error message. 
                          That's a good default behavior, and you've seen it many times. You can add a "try/except" structure to your code to handle exceptions, like this:


                      </p>
                      <code>
                          try:
                          ## Either of these two lines could throw an IOError, say
                          ## if the file does not exist or the read() encounters a low level error.
                          f = open(filename, 'rU')
                          text = f.read()
                          f.close()
                        except IOError:
                          ## Control jumps directly to here if any of the above lines throws IOError.
                          sys.stderr.write('problem reading:' + filename)
                        ## In any case, the code then continues with the line after the try/except
                      
                      </code>
                    
                    </article>
                  </section>
        <section class="main-section" id="Reference">
          <header>Reference</header>
          <article>
            <ul>
              <ul>
                All the documentation in this page is taken from
                <a
                  href="https://developers.google.com/edu/python"
                  target="_blank"
                  >Google's Python Class</a
                >
              </ul>
            </ul>
          </article>
        </section>
      </main>
</body>

            <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</html>